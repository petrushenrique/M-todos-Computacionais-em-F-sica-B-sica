\chapter{Introdução ao Python}\label{ch:1}

Python é uma poderosa linguagem de programação de propósito geral desenvolvida por Guido van Rossum\footnote{Quando começou a implementar o primeiro interpretador Python, Guido van Rossum também estava assistindo a série ``Flying Circus'' do famoso grupo de comédia Inglês ``Monty Python''. Van Rossum pensou que precisava de um nome que fosse curto, único e um pouco misterioso, então decidiu chamar a linguagem de Python} em 1989.  É classificada como uma linguagem de programação de alto nível na medida em que lida automaticamente com as operações mais fundamentais (como gerenciamento de memória) realizada no nível do processador (“código de máquina”). É considerado um nível superior linguagem do que, por exemplo, C++, por causa de sua sintaxe (que é próxima de linguagem natural, no caso o inglês) e rica variedade de estruturas de dados nativas, como listas, tuplas, conjuntos e dicionários (vamos discutir um pouco delas no Apêndice \ref{ap:1.1}). Na verdade o Python, como outras linguagens de alto nível, é um interpretador. Em uma linguagem interpretada como o Python, cada comando é analisado e convertido “ao longo do caminho”. Esse processo torna a linguagem interpretada significativamente mais lenta; mas a vantagem é que elas são mais simples para se programar ajustar e depurar porque você não tem para recompilar o programa após cada alteração.

O Python apresenta algumas vantagens:
\begin{enumerate}
    \item Sua sintaxe limpa e simples torna a escrita de programas Python rápida, simples e geralmente minimiza as chances para que os bugs se infiltrem.
    \item É gratuito – Python e suas bibliotecas  associadas são gratuitas e de código aberto, ao contrário de ofertas comerciais como Mathematica e MATLAB.
    \item Suporte multiplataforma: Python está disponível para todos os com-
computador, incluindo Windows, Unix, Linux e macOS.
    \item O Python possui uma grande biblioteca de módulos e pacotes que estendem sua funcionalidade. Isso é ferramentas já prontas que nos permitem realizar uma diversidade de operações complexas comuns como as de álgebra linear, derivação, integração, operações matemáticas simbólicas, construção de gŕaficos. Muitos deles estão disponíveis como parte da “Biblioteca Padrão” fornecida com o próprio Python. Outros, incluindo o NumPy, SciPy, Matplotlib (algumas dessas estão discutidas nos Apêndices) e bibliotecas pandas usadas em computação científica, podem ser baixadas gratuitamente.
    \item Python é relativamente fácil de aprender. A sintaxe e as expressões idiomáticas usadas para operações básicas são aplicados de forma consistente no uso mais avançado da linguagem. Mensagens de erro geralmente são avaliações significativas do que deu errado, e não os alertas genéricos de “travamentos” que podem ocorrer em linguagens compiladas de baixo nível.
    \item Python é flexível: muitas vezes é descrito como uma linguagem “multi-paradigma” que contém os melhores recursos dos paradigmas procedimentais, orientados a objetos e funcionais.
\end{enumerate}

É claro que o Python também possui algumas desvantagens:
\begin{enumerate}
    \item A velocidade de execução de um programa Python não é tão rápida linguagens de mais baixo nível como C++ e Fortran. Para aplicações numéricas pesadas, algumas bibliotecas como o NumPy e o SciPy minimizam essa perda de velocidade pois elas mesmas são códigos C++ escondidos sobre uma ``tradução'' para Python. 
    \item Para fornecer simplicidade a linguagem, o Python usa quantidade de memória maior. Isso pode ser uma desvantagem ao criar aplicações que demandem um uso otimizado de memória. Por essa razão e pela menor velocidade, o Python é pouco utilizado para aplicativos móveis e para servidores.
    \item Python é uma linguagem dita dinâmica. Com isso uma variável que em um dado momento do código é um número inteiro, em outro ponto do código pode ser tornar uma string (e.g. um texto). Isso se chama {\it Mutabilidade} e pode gerar alguns erros. Isso requer que códigos mais complexos sejam bastante testados.
\end{enumerate}

Em resumo, Python é uma linguagem de programação moderna e bem projetada, ao mesmo tempo fácil de aprender e muito poderosa. Ou seja embora seja simples o suficiente para permitir que estudantes sem experiência prévia em programação resolvam problemas já início da graduação, O Python também é poderoso o suficiente para ser usado para trabalho numérico em física. Na próxima seção, discutimos como instalar o Python em um sistema operacional Linux.

\section{Instalação}\label{sc:1.1}

Verifique se já tem o Python instalado, se você usa GNU/Linux, provavelmente já possui alguma versão do Python instalada por padrão. Para conferir, digite em um terminal:

\begin{lstlisting}[language=bash]
  $ which python3
\end{lstlisting}
O Python 3 é a versão atual do Python\footnote{O Python 2 foi descontinuado em 2020.}, por ser o futuro da linguagem e pelo fato de sua versão anterior estar em processo de descontinuação.
Caso o Python esteja instalado, o sistema vai retornar algo como
\begin{lstlisting}[language=bash]
  /usr/bin/python
\end{lstlisting}
Caso contrário, o sistema retornará algo do tipo
\begin{lstlisting}[language=bash]
  which: no python 
  in (/usr/local/sbin:/usr/local/bin:/usr/bin:/usr...)
\end{lstlisting}

Caso o Python não esteja instalado podemos instala-lo via um gerenciador de pacotes da distribuição do Linux instalada na máquina. Os gerenciadores de pacotes mais comuns são apt-get que funcionam em distribuições como o Debian, o Ubuntu e o Mint. Para instalar o Python usando o apt-get digite em um terminal:
\begin{lstlisting}[language=bash]
  $ sudo apt-get install python3
\end{lstlisting}
É comum que no desenvolvimento de projetos Python, precisemos instalar diversas bibliotecas para diferentes necessidades. Essas bibliotecas podem ser instaladas manualmente, mas o processo pode ser complicado. Para contornar esse problema, o Python possui uma ferramenta para gerenciamento de pacotes chamado PIP. Isso em geral não é necessário em distribuições Linux como Debian, Ubuntu e Mint. Para instalar o gerenciador de pacotes pip, digite em um terminal:

\begin{lstlisting}[language=bash]
  $ sudo apt-get install python3-pip
\end{lstlisting}
Caso sua distribuição utilize um gerenciador de pacotes diferente deste (ou você utilize Windows) {\it \bf não entre em pânico}, na internet há instruções passo a passo para instala-lo. 

Para ver a versão do Python que você tem instalado digite no terminal
\begin{lstlisting}[language=bash]
  $ python3 --version
\end{lstlisting}
Após a instalação você poderá usar o Python diretamente do terminal. Por exemplo, digite
\begin{lstlisting}[language=bash]
  $ python
  $ 6*7
  $ a=10**3
  $ print(a)
  $ quit()
\end{lstlisting}

É claro seria muito inconivente escrever um código diretamente no terminal. Precisamos agora instalar uma IDE (ambiente de desenvolvimento integra, do inglês {\it Integrated Development Environment}). Existem várias IDE para Python, durante o curso utilizaremos o Jupyter-Notebook. Para instala-la digite no terminal:

\begin{lstlisting}[language=bash]
  $ sudo apt-get install jupyter-notebook
\end{lstlisting}

Para iniciar o notebook digite no terminal o seguinte comando:
\begin{lstlisting}[language=bash]
  $ jupyter-notebook
\end{lstlisting}
O Jupyter Notebook deverá abrir em seu browser de internet.

\section{Primeiros Passos no Jupyter Notebook}

Quando o Jupyter Notebook abrir em seu navegador você verá o Dashboard do Jupyter Notebook, o qual irá exibir uma lista dos notebooks, arquivos e subdiretórios no diretório onde o servidor do notebook foi inicializado. Na maioria das vezes, você irá querer que o servidor do notebook inicie no diretório de nível mais alto que contenha os notebooks. Geralmente este será seu diretório home. A tela deve se parecer com a tela abaixo (Fig. \ref{fig:JN-Dashboard})
\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{Images/jupyter-dashboard.jpg}
\caption{Exemplo do Dashboard do Jupyter Notebook, a primeira tela que você deve ver quando abre o Jupyter.}\label{fig:JN-Dashboard}
\end{figure}
Isso ainda não é o que chamamos de um notebook, mas {\it \bf não entre em pânico}. O dashboard é o gerenciador de arquivos que seve para você selecionar, procurar e organizar seus notebooks. A interface é bastante simples de se entender. Vamos começar criando um diretório para guardarmos nossos projetos em Python. Para isso clique no menu {\tt New} no canto superior direito e selecione a opção {\tt Folder} (veja a Fig. \ref{fig:JN-NEW}.)
\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{Images/new-notebook-menu.jpg}
\caption{O menu {\tt New} permite abir um novo ({\tt Python 3}), criar um arquivo de texto ({\tt Text File}), Folder ({\tt Folder}) ou abrir um terminal ({\tt Termial}).}\label{fig:JN-NEW}
\end{figure}
O diretório é criado com o nome {\tt Untitled Folder} (i.e. dirétório sem título). Para renomear um folder ou arquivo, no dashboard, você deve marcar a caixa de seleção à esquerda do nome do folder ou arquivo e clicar na opção {\tt Rename}, que fica disponível na barra de menu após a caixa de seleção ser ativada (veja a Fig. \ref{fig:JN-Rename}.)
\begin{figure}[h!]
\centering
\includegraphics[scale=0.28]{Images/rename-folder.png}
\caption{Marcando a caixa de seleção de um arquivo ou folder você pode renomeá-lo ({\tt Rename}), mover sua localização na árvore de diretórios ({\tt Move}) ou deleta-lo (ícone da lixeira). }\label{fig:JN-Rename}
\end{figure}

Vamos agora criar um notebook, para isso selecione a opção {\tt Python 3} no menu {\tt New}. Uma tela como a abaixo deverá aparecer (veja a Fig. \ref{fig:JN-Notebook})
\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{Images/new-notebook.jpg}
\caption{Tela inicial de um notebook}\label{fig:JN-Notebook}
\end{figure}
No menu superior, você verá opções tradicionais como {\tt File}, {\tt Edit}, {\tt View}, {\tt Insert} e {\tt Help}, suas funções são intuitivas e você pode explora-las para conhecer suas funcionalidades. Nesse Menu aparecem dois termos importantes: {\tt Cell} (células) e {\tt Kernel} (núcleos).
\begin{itemize}
    \item {\bf Kernel:} é o nome dado pelo Jupyter Notebook a um “mecanismo computacional” que interpreta o código contido em um documento de notebook. Haverá um kernel para cada linguagem suportada pelo Jupyter Notebook. Basicamente, um kernel Python 3 conversa com o kernel do sistema operacional (no caso um kernel Linux) para executar os comandos.
    \item {\bf Cell:} é um bloco para o texto a ser exibido no notebook ou código a ser executado pelo kernel do notebook.
\end{itemize}
Na Fig. \ref{fig:JN-Notebook}, essa caixa com o contorno verde é uma célula vazia e esta marcada por {\tt In [ ]:}. As células formam o corpo de um notebook.  Existem 4 tipos de células: 
\begin{enumerate}
    \item {\bf \tt Code:} Células de código que contém as serem executadas no kernel. Quando o código é executado, o notebook exibe a saída abaixo da célula de código que o gerou.
    \item {\bf \tt Markdown:} Células de texto que são formatadas usando Markdown, sua saída é exibida no local quando a célula Markdown é executada.
    \item {\bf \tt Heading:} Células de texto formatadas como título, sua saída é exibida no local quando a célula Heading é executada.
    \item {\bf \tt Raw NBConvert:} Células de texto que não serão formatadas.
\end{enumerate}
O tipo de célula esta indicado na toolbar e nesse mesmo local podemos modificar o tipo da célula. Veja a Fig. \ref{fig:JN-CodeCell}
\begin{figure}[h]
\centering
\includegraphics[scale=0.45]{Images/select-code-cell.png}
\caption{Você pode verificar o tipo de célula de qualquer célula em um Jupyter Notebook clicando na célula e olhando para o tipo de célula na toolbar.}\label{fig:JN-CodeCell}
\end{figure}
Os tipos mais utlizados são o {\tt Code} e o {\tt Markdown}. Deixemos a célula como tipo {\tt Code}, e façamos um primeiro código simples. Comecemos com o clássico dos clássicos da programação digitando {\tt print('Hello, World')}, como mostra a Fig. \ref{fig:JN-HelloWorld}. A execução do código nesta célula pode ser feita clicando no ícone de execução da célula na toolbar ou pressionando as teclas {\tt Shift + Enter}.
\begin{figure}[h]
\centering
\includegraphics[scale=0.44]{Images/helloword.png}
\caption{Execução da célula de código muda {\tt In []} para {\tt In [1]}. O comando {\tt print} imprime o conteúdo entre parenteses, as aspas simples indicam que o conteúdo é do tipo texto. A saída da célula de código executada aparece logo abaixo da mesma.} \label{fig:JN-HelloWorld}
\end{figure}
O Jupyter Notebook oferece ajuda no próprio notebook para os commandos Python. Isso pode ser feito via os comandos:
\begin{enumerate}
    \item {\tt help()} mostra a documentação disponível para este objeto, método e função disponíveis para esse objeto.
    \item {\tt dir()} mostra as possíveis chamadas de objeto, método e função disponíveis para esse objeto.
\end{enumerate}
Teste por exemplo {\tt help(print)} e {\tt dir(print)}. Documentações mais detalhadas para comandos mais comuns podem ser encontradas no menu {\tt Help}. Além disso, sempre vale lembrar que existem uma farta documentação do Python e seus pacotes da internet.

O Jupyter Notebook também fornece alguns ``comandos mágicos'', que atalhos úties para vários problemas comuns na computação científica. Comandos mágicos vêm em dois tipos: ``magias de linha'', que são indicadas por um único prefixo \footnote{caso o Jupiter Notebook esteja com a opção Automagic ligada não é necessário o \% para usar ``mágicas de linha''.} \% e operam em uma única linha de entrada, e ``magias de célula'', que são indicadas por um prefixo \%\%  e operam em toda uma célula. Um exemplo é caso em queremos saber quanto tempo levamos para executar uma instrução. Para isso podemos usar o ``comando mágico'' {\tt timeit}, como no exemplo abaixo
\begin{lstlisting}[language=Python]
  %timeit list(range(100000))
\end{lstlisting}
essa instrução fará o Jupyter Notebook medir quanto tempo o sistema levará para construir uma lista de 100 mil elementos. Este comando também pode ser aplicado a toda uma célula como por exemplo:
\begin{lstlisting}[language=Python]
%%timeit
a = list(range(100000))
b = [n + 1 for n in a]
\end{lstlisting}
aqui medimos o tempo para se criar a lista {\tt a} e a lista {\tt b}. Em ambos os casos o tempo deve ser da ordem de alguns milisegundos (vai variar de computador para computador).
Uma lista com outros ``comandos mágicos'' pode ser acessada usando {\tt \%lsmagic}, referências mais detalhadas destes comandos podem ser obtidas usando {\tt \%quickref}. Veja e teste por exemplo os comandos {\tt \%hist}, {\tt \%ls}, {\tt \%magik}. Você aprenderá a usar essas ferramentas a medida que você for desenvolvendo mais e mais projetos no Python. Não se preocupe em memoriza-las. 


Um grande benefício do Jupyter Notebook é que ele permite combinar código (Code) e texto (Markdown) em um documento, para que você possa documentar facilmente suas ideias e fluxo de trabalho. Isso é extremamente útil para comunicar seu trabalho a outros físicos que poderão acompanhar mais detalhadamente sua ideiam mas também é útil para te orientar onde você parou em um projeto, mantendo registrada uma ideia que você estava seguindo. Lembre-se que para deixar a célula no tipo texto selecione a opção Markdown no menu da toolbar mostrado na Fig. \ref{fig:JN-CodeCell}. 

O Markdown é uma sintaxe legível por humanos (também conhecida como linguagem de marcação) para formatar documentos de texto. O Markdown pode ser usado para produzir documentos bem formatados, incluindo PDFs e páginas da web. Formatar um texto usando Markdown, é semelhante a usar as ferramentas de formatação em um editor de texto como o Microsoft Word ou o Google Docs. No entanto, em vez de usar ícones para aplicar a formatação, você usa uma sintaxe de comandos como {\tt **essa sintaxe coloca o texto em negrito no markdown**} ou {\tt \# Aqui está um título.} A Fig. \ref{fig:JN-Markdown-Raw} mostra um exemplo desta formatação. Uma célula Markdown é executada da mesma forma que uma célula de código. Após executarmos a célula com o código Markdown obtemos o texto formatado conforme as instruções. A saída do exemplo acima corresponde a Fig.
\ref{fig:JN-Markdown-Raw} esta mostrada na Fig. \ref{fig:JN-Markdown-prod}.
\begin{figure}[ht]
\centering
\includegraphics[scale=0.4]{Images/markdown-raw.png}
\caption{Uma célula Markdown com código antes de ser formatado. Nela vemos exemplos usuais de formatação para títulos, negrito, itálico e listas. Mais informações sobre sintaxe de formatação Markdown podem ser encontradas em \href{https://www.markdownguide.org/}{markdownguide.org}} \label{fig:JN-Markdown-Raw}
\end{figure}
\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{Images/markdown-prod.png}
\caption{Saída de uma célula Markdown.} \label{fig:JN-Markdown-prod}
\end{figure}

O Markdown também é capaz de lidar com imagens, hyperlinks e vários outras necessidades de edição de texto. Para o trabalho em física é bastante importante que possamos escrever com facilidade expressões matemáticas. Isso é feito utilizando comandos \LaTeX. O \LaTeX é uma linguagem de preparação de documentos para composição tipográfica de alta qualidade. É mais frequentemente usado para documentos técnicos ou científicos de médio a grande porte, mas pode ser usado para quase qualquer forma de publicação. Este texto por exemplo foi preparado com \LaTeX, assim como o são a grande maioria das publicações científicas nas áreas de física. Você pode aprender mais sobre a linguagem \LaTeX no apêndice \ref{a:latex}. As Fig. \ref{fig:JN-Latex-in} e \ref{fig:JN-Latex-out} mostram respectivamente comandos \LaTeX em uma célula Markdown e mesma célula após o processamento.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.45]{Images/word-image-751.png}
\caption{Comandos \LaTeX em uma célula Markdown sendo utilizados para escrever uma equação.} \label{fig:JN-Latex-in}
\end{figure}
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Images/word-image-752.png}
\caption{Saída da célula Markdown da Figura anterior} \label{fig:JN-Latex-out}
\end{figure}

\section{Operações Matemáticas Simples}\label{sc:ops}

Até aqui, nosso conhecimento de Python nos permite fazer muito pouco, certamente nada que fosse útil para a física. A primeira coisa que precisamos conseguir utiliza-lo é entender como fazer operações aritméticas. Na maioria dos lugares onde você pode usar uma única variável em Python, você também pode use uma expressão matemática, como ``x+y''. Assim, por exemplo 
\begin{lstlisting}[language=Python]
  x = 1
  y = 2
  print(x+y)
\end{lstlisting}
computador calculará a soma de x e y para você e imprima o resultado. As operações matemáticas básicas são 
\[ \begin{array}{cc}
    x + y & \textrm{adição} \\
    x - y & \textrm{subtração} \\
    x * y & \textrm{multiplicação} \\
    x / y & \textrm{divisão} \\
    x ** y & x\text{ elevado a potência} y
\end{array} \]
Nesse ponto precisamos destacar que essas operações não agem somente em números e seu resultado depende do tipo de variáveis com as quais estamos lidando. Novamente, {\bf não entre em pânico}, vamos discutir rapidamente sobre variáveis na próxima seção e você ter mais informações no Apêndice \ref{ap:1.1}. Mas aqui vale um exemplo simples considere o caso:
\begin{lstlisting}[language=Python]
  x = 'Fi'
  y = 'si'
  z = 'ca'
  print(x+y+z)
  n = 3
  print(n*(x+y+z))
\end{lstlisting}
Nesse exemplo as variáveis x, y e z são do tipo {\it string} e o Python entende a operação $+$ como concatenação dessas strings. Já n é um variável do tipo inteiro e o Python entende a operação de multiplicar um inteiro com a string x+y+z, como concatenar n vezes essa string. Essa versatilidade do Python é uma de suas características úteis, mas também pode gerar erros.

Em Python, todos os operadores matemáticos $+$ (adição), $-$ (subtração), $*$ (multiplicação) funcionam como seria de esperar em números e variáveis numéricas. Ou seja contanto que você fique com os tipos de variáveis numéricas, adição, subtração e
multiplicação não deve haver muitos problemas. A divisão (/) tem algumas particularidades. Funciona perfeitamente em variáveis do tipo float, que são aquela usadas para descrever números via notação decimal, mas se operando entre inteiros o resultado é convertido para float. Veja os exemplos abaixo:
\begin{lstlisting}[language=Python]
  print(1/2)
  print(1./2.)
  print(1./2)
\end{lstlisting}
Cuidado que há uma mudança entre o Python 2 e o Python 3, neste aspecto.

O Python também possui dois outros tipos de ``divisão'' que são menos comuns que divisão usual, são elas:
\[ \begin{array}{cc}
    x // y & \textrm{O quotiente ou parte inteira da divisão} \\
    x \% y & \textrm{O resto ou operador módulo}
\end{array} \]
O quociente entre {\tt x} e {\tt y}, {\tt x//y},  é a parte inteira de {\tt x} dividida por {\tt y}, o que significa que {\tt x} é dividido por {\tt y} e a parte fracionária é descartada. O operador módulo entre {\tt x} e {\tt y}, {\tt x \% y}, é a parte inteira restante da divisão de {\tt x} por {\tt y}. Por exemplo, compare:
\begin{lstlisting}[language=Python]
  print(1.5 / 0.4)
  print(1.5 // 0.4)
  print(1.5 % 0.4)
\end{lstlisting}

As regras de precedência em Python são exatamente o que deveriam ser em qualquer
sistema matemático: (); então **; então *, /, \%, // na ordem da esquerda para a direita; e
finalmente +, - na ordem da esquerda para a direita.

Em Python o símbolo $=$ não significa 'é igual a', ou seja a expressão em Python {\tt x = y}, não é uma equação. No Python,  {\tt x = y} deve ser entendida como uma instrução para que o computador atribua a variável {\tt x} o valor da variável {\tt y}. O seguinte exemplo pode ser instrutivo
\begin{lstlisting}[language=Python]
  x = 1
  x = x + 1
  print('x =', x)
\end{lstlisting}
A primeira instrução atribui a variável {\tt x} o valor 1, a segunda instrução (que se entendida como uma equação matemática é absurda) pega o valor atual de {\tt x} é adiciona uma unidade. Quando a instrução {\tt print(x)} é executada imprimisse o valor de {\tt x} após a última instrução que o atualizou, ou seja obtemos {\tt x = 2}. Um truque  útil no Python, são as operadores {\it modificadores}, que permitem fazer alterações em uma variável da seguinte forma:
\[\begin{array}{cc}
{\tt x += y} & \text{\tt adicione\, y\, a\, x, ou seja, x = x + y}\\
{\tt x -= y} & \text{\tt subtrair y de x, ou seja x = x - y}\\
{\tt x *= y} & \text{\tt multiplicar x por y, ou seja x = x*y}\\
{\tt x /= y} & \text{\tt divide x por y, ou seja x = x/y}\\
{\tt x //= y} & \text{\tt divide x por y e arredonda para um inteiro, ou seja x = x//y}
\end{array}\]

Uma outra operação comum em Python é {\tt x == y}, esta é uma operação de comparação e seu resultado é uma variável do tipo {\it booleana}, ou seja é {\tt True} (verdadeiro) ou {\tt False} (falso). Ou seja a instrução {\tt x == y} é um condicional, i.e. equivale a pergunta ``o valor atual da variável {\tt x} é igual ao valor atual da variável {\tt y}?''. Algumas outras operações de comparação (e portando com saída True ou False) comuns no Python são
\[\begin{array}{cc}
{\tt x != y} & \text{\tt x é diferente de y?}\\
{\tt x < y} & \text{\tt x é menor que y?}\\
{\tt x <= y} & \text{\tt x é menor ou igual a y}\\
{\tt x > y} & \text{\tt x é maior que y?}\\
{\tt x >= y} & \text{\tt x é maior ou igual a y?}
\end{array}\]

\section{O ``Bê-a-bá'' sobre variáveis.}

Em programação, variáveis representam entre outras coisas instruções para computador guardar dados em sua memória, para serem usados posteriormente. São elementos fundamentais nos códigos computacionais. Por isso, vale a pena discutir como o Python lida com
variáveis. Tenha em mente que o que esta escrito no lado direito do operador de atribuição $=$ é um dado, equanto o que esta escrito no lado esquedo é um rótulo ou etiqueta para um local na memória do computador. Vamos ilustrar esse processo. Quando Python interpreta uma linha como {\tt x = 2} , ele começa do lado direito e segue a leitura para a esquerda. Então, dada a instrução {\tt x = 2} , o interpretador Python recebe o ``2'', reconhece-o como um inteiro e armazena-o em uma ``caixa'' de tamanho inteiro na memória. Em seguida, ele pega o rótulo {\tt x} e usa-o como um ponteiro para esse local de memória. Esse processo é mostrado na primeira parte da Fig. \ref{fig:memory}.
\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{Images/memory.png}
\caption{Atribuição de valores a variáveis e como o Python instruirá o computador a guardá-los na memória. Cada caixa representa uma localização na memória do computador.}\label{fig:memory}
\end{figure}

Quando encontra a instrução {\tt y = x}, o Python começa a partir da
direita {\tt x} e, reconhecendo x como um ponteiro para um local de memória, aponta o ponteiro {\tt y} para o mesmo local de memória. Esta é a segunda parte da Fig. \ref{fig:memory}. Continuando nesse processo, quando receber a instrução {\tt x = 1}, novamente o Python começa na direita e recebe o inteiro ``1'' e o aloca em uma `caixa'' de tamanho inteiro na memória. Só então ele executa o lado esquerdo da instrução, isso é, desloca o ponteiro rotulado como {\tt x} para esse novo espaço de memória. Isso não muda para onde o ponteiro {\tt y} esta apontado. Agora quando o Python receber a instrução {\tt y = 1}, ele ocupará um terceiro local na memória, e desviará o ponteiro {\tt y} para este local. Este local não será o mesmo para o qual esta apontado o ponteiro {\tt x}, para o Python não há razão para que os dois ponteiros apontem para o mesmo espaço de memória. Essa situação esta ilustrada na terceira parte da Fig. \ref{fig:memory}. Note que nesse momento não há nenhum ponteiro apontado para o bloco ocupado pelo valor $2$. Este bloco esta ocupado com dados que não são imediatamente apagados\footnote{É um ``lixo'' que fica na memória e pode comprometer o desempenho do sistema.}, mas o sistema entende que aquele espaço de memória esta livre para ser usado.

Essa interpretação de dados a direita e rótulos a esquerda permite que você faça algumas coisas muito úteis. Por exemplo, analisemos a instrução {\tt x = x + 1}. A direita o computador reconhecerá {\tt x} como um ponteiro apontando para uma valor, lê esse valor é o adiciona a $1$, como no final da Fig.\ref{fig:memory}, obtendo o valor $2$. Ele então desloca o ponteiro {\tt x} para aquela  nova ``caixa'' de memória.

Em Python também podemos atribuir múltiplos rótulos para um dado como por exemplo com a instrução {\tt w = x = y = z = 'Fisica'}. Neste caso, cada uma dessas variáveis
acabam apontando exatamente para o mesmo ponto na memória, até que sejam usadas para
outra coisa. O Python também permite que você atribua dados a mais de uma variável em uma mesma instrução. Por exemplo, {\tt a,b = 1, 2} funciona porque Python analisa os dados a direita da igualdade primeiro e reconhece um par de inteiro, então atribui esse par ao par de rótulos à esquerda. Isso é útil por nos permite trocar os valores de duas variáveis fazendo por exemplo {\tt x, y = y, x}. Analise por exemplo o código abaixo
\begin{lstlisting}[language=Python]
a = b = 1
a , b = b, a+b
print('a =', a, 'b=', b)
\end{lstlisting}
Para a maior parte das aplicações, conhecer detalhadamente como o Python gerencia variáveis não é necessário.

\subsection{Nomeando Variáveis}\label{sc:naming-var}
O nome de uma variável podem conter letras, números e o caractere \_. Esses nomes nunca podem começar com um número. E é importante lembrar que o Python diferencia maiúsculas e minúsculas. Ou seja portanto, {\tt Raio\_1} não é o mesmo que {\tt raio\_1}. É uma boa prática escolher nomes de variáveis que esclareçam a função daquela variável. Por exemplo, o nome {\tt m} é perfeitamente legal, mas quando um colega for ler o seu código o nome  {\tt massa\_partícula} é muito mais descritivo. O tempo extra que você gasta digitando esses nomes mais descritivos será mais do que compensado no momento em que você economiza depurando seu código!

As variáveis também não podem receber o mesmo nome de algumas palavras reservadas tais como:
\begin{table}[h!]
    \centering
    {\tt 
    \begin{tabular}{cccccc}
    and & as &  assert & async & await & break \\
    class & continue &  def & del & elif & else \\
    except & finally &  for & from & global & if \\
    import & in &  is & lambda & nonlocal & not \\
    or & pass & raise & return & try & while \\
    with & yield &  False & True & None &  \\
    \end{tabular}}
    \caption{Lista de Palavras Reservadas no Python 3}
    \label{tab:my_label}
\end{table}

É possível nomear uma variável usando o nome de uma função do Python (e.g. {\tt print}), mas a partir disso a função não ficará mais disponível. Portanto essa prática não é recomendável. Você também deve evitar nomes como ``I'', ``l'', ``O'' e ``o'' para evitar confusão com os números 1 e 0. Nomes como {\tt n,i,j,k} são usualmente reservados para contadores inteiros. Essas e muitas outras regras e convenções estão codificadas em um guia de estilo chamado PEP8 que faz parte da documentação do Python, e pode ser acessado em \href{https://peps.python.org/pep-0008/}{https://peps.python.org/pep-0008/}.

\subsection{Alguns tipos de variáveis}

Todas as variáveis em Python possuem uma certa natureza ou como se diz são de certos tipos. Isso significa que os dados que elas rotulam têm certas propriedades que ditam como elas são usadas. Tipos diferentes têm propriedades diferentes e são utilizados para diferentes aplicações. Você sempre pode determinar o tipo de uma variável (ou de um dado) usando a função interna {\tt type()}. Veja o exemplo abaixo:
\begin{lstlisting}[language=Python]
dimensao = 3
FortyTwo = 'Vida, Universo e Tudo Mais'
pi = 3.1415
z = 1 + 1j
Fibonacci_5 = [1, 1, 2, 3, 5]
type(dimensao),type(FortyTwo),type(pi),type(z),type(Fibonacci_5)
\end{lstlisting}

Existem diversos tipos diferentes de variáveis em Python. Os dois tipos mais comuns 
podem ser divididos em {\it tipos numéricos} e {\it tipos sequenciais}. Tipos numéricos
contêm dados que representam um números únicos, como por exemplo ``42'', ``3,1415'' e ``1 + 3j''. Tipos sequenciais contêm dados com vários objetos, que podem ser números ou
caracteres, ou mesmo coleções de diferentes tipos de objetos. Um dos pontos fortes do Python é que ele automaticamente converte entre tipos de variáveis conforme é necessário e se possível. Essa mutabilidade das variáveis também pode levar a armadilhas que produzem erros no código. Discutiremos aqui os tipos numéricos e sequenciais, você pode ver mais sobre outros tipos no apêndice \ref{ap:1.1}.

\subsubsection{Tipos Numéricos}
As variáveis numéricas em Python, podem ser de 3 tipos: inteiros (type: int ), números de ponto flutuante (type: float) e números complexos (type: complex).

\paragraph{Integer:} O inteiro é o tipo numérico mais simples em Python. Os inteiros são
usados para contar itens ou acompanhar quantas vezes você fez alguma coisa. Eles podem ser negativos ou positivos, ou seja eles correspondem ao que chamamos de números inteiros. Lembre que como já discutimos na seção \ref{sc:ops}, variáveis do tipo {\tt int} não se dividem como esperado: Em Python, {\tt 1/2} resulta em {\tt 0}, porque $2$ cabe em $1$ zero vezes.
\paragraph{Float:} O tipo “floating point” (i.e. ponto flutuante) é um número que contém um ponto decimal dividindo sua parte inteira de sua parte fracionária. Por exemplo, $3.1415$ e $9.81$ são do tipo float. Tipos float também podem ser escritos usando notação científica por exemplo {\tt 6.022e23} corresponde a $6.022 \times 10^{23}$ é um float. 
\paragraph{Complex:} Números complexos são embutidos no Python, que usa $j=\sqrt{-1}$ para unidade imaginária. Essas variáveis são do tipo $a+bj$, onde a parte real do número é $a$ e a parte imaginária é $b$. O Python executa corretamente as operações elementares com números complexos.

Números em Python N são objetos (na verdade, tudo em Python é um objeto) e têm certos
{\it atributos}, acessados usando a notação: {\tt <objeto>.<atributo>} (este uso do
período não tem nada a ver com o ponto decimal que aparece em um tipo float. Alguns atributos são valores simples: por exemplo, objetos de números complexos têm a
atributos real e imag , que são as partes real e imaginária (ponto flutuante) do
número. Teste por exemplo
\begin{lstlisting}[language=Python]
(1 + 2j).real
(1 + 2j).imag
\end{lstlisting}
Nesses objetos também é possível aplicar neles {\it métodos}, ou seja aplicar algumas funções no mesmo. Por exemplo
\begin{lstlisting}[language=Python]
(1 + 2j).conjugate()
42.bit_length
(3.14159265359).bit_length
\end{lstlisting}
Digitando-se {\tt <objeto>.} e pressionando a telca Tab o Jupyter Notebook abrirá um menu com uma lista de métodos que são possíveis de se aplicar naquele objeto. 

\subsubsection{Tipos Sequenciais}
Tipos sequenciais são coleções de itens que são rotulados por um nome de variável. Os itens individuais dentro da coleção são separados por vírgulas, e referido por um índice entre colchetes após o nome da variável. Veja o exemplo:
\begin{lstlisting}[language=Python]
Disciplinas  = ('Termodinamica', 'Eletromagnetismo', 
        'Quantica', 'Estado Solido')
print(Disciplinas[2])
\end{lstlisting}
O resultado destas instruções deve ser {\tt Quantica}. Note que o índice começa a contar de 0. Você pode usar também índices negativos para contar de trás para a frente, por exemplo
\begin{lstlisting}[language=Python]
print(Disciplinas[-1],Disciplinas[-3])
\end{lstlisting}
Vamos examinar agora alguns tipos sequencias específicos utilizados no Python.

\paragraph{Tuple} As Tuplas são indicadas por parênteses: (). Itens em tuplas podem ser
qualquer outro tipo de dados, incluindo outras tuplas. Tuplas são {\it imutáveis},
o que significa que uma vez definidos seus conteúdos não podem ser alterados. Por exemplo, as instruções abaixo irão gerar um erro:
\begin{lstlisting}[language=Python]
teste = (1,2,3)
type(a)
print(a[1])
a[1] = 'dois'
print(a)
\end{lstlisting}

\paragraph{List} As listas são indicadas por colchetes: [ ]. As listas são praticamente o
iguais às tuplas, mas são {\it mutáveis}: itens individuais em uma lista podem ser
modificados. As listas podem conter qualquer outro tipo de dados, incluindo outras listas. Note a diferença trocando os parênteses por colchetes na primeira linha das instruções acima
\begin{lstlisting}[language=Python]
teste = [1,2,3]
type(a)
print(a[1])
a[1] = 'dois'
print(a)
\end{lstlisting}

\paragraph{String} Uma string é uma sequência de caracteres. As strings são delimitadas por
aspas simples ou duplas: " " ou ' '. Strings são {\it imutáveis}, como tuplas. Ao contrário das listas ou tuplas, as strings só podem incluir caracteres. O exemplo abaixo mostra algumas operações com strings.
\begin{lstlisting}[language=Python]
Palavra='trabalho e Energia'
print(Palavra)
print(Palavra[1])
print(Palavra[:5])
print(Palavra[-4:])
print(Palavra.capitalize())
print(Palavra.count('a'))
print(Palavra.split())
\end{lstlisting}

\paragraph{Dictionary} Os dicionários são indicados por colchetes: { }. Eles são dif-
diferente dos outros tipos sequenciais em Python, pois em vez de índices numéricos que eles usam keywords são rótulos de strings.

\paragraph{Range} Um tipo range representa uma sequência {\it imutável} de números e é comumente usado para fazer um loop de um número específico de vezes em loops. Um range é criado por uma instrução {\tt range({\it start}, {\it stop}, {\it step})}, onde {\it start} é o índice inicial\footnote{O argumento {\it start} é opcional, se omitido o range começa por padrão em 0.}, {\it stop} o índice final (que não é incluído), e {\it step}\footnote{O argumento {\it step} é opcional, se não incluído o intervalo padrão é 1.}  o intervalo entre os índices. Veja o exemplo abaixo
\begin{lstlisting}[language=Python]
Pares = range(0,100,2)
print('Pares =', type(Pares))
print(Pares)
print('Os primeiros pares:', Pares[0], Pares[1], Pares[2])
Pares_list = list(Pares)
print(Pares_list)
\end{lstlisting}
A última instrução mostra como converter uma variável tipo range em uma variável tipo list.

Conforme mencionado acima na descrição das listas, uma lista pode conter como elementos outras listas. Uma lista de listas lembra bastante uma matriz bidimensional. Veja por exemplo:
\begin{lstlisting}[language=Python]
matrix = [[1,2,3],[4,5,6]]
print(matrix[1][1])
\end{lstlisting}
Que resulta em 5 (não se esqueça que os índices começam em 0). Há alguma utilidade em visualizar listas desse tipo como matrizes, mas estes objetos não operam como matrizes. Teste por exemplo {\tt print(matrix + matrix)} e você verá que o Python apenas concatena as listas. Novamente, {\bf não entre em pânico}, algumas bibliotecas como o SciPy e o NumPy vão adicionar funcionalidades que nos permitirão usar matrizes como conhecemos.

Listas são objetos bastante úteis e comuns. Veja o exemplo abaixo para algumas operações úteis com listas.
\begin{lstlisting}[language=Python]
primes = [2, 3, 5, 7, 11, 13]
primes.append(17)
print(primes)
primes.reverse()
print(primes)
primes.pop(6)
print(primes)
primes.sort()
print(primes)
primes = primes+2*['a']+['b']+['c']+['b']
print(primes)
primes.remove('a')
print(primes)
primes.pop(-1)
print(primes)
\end{lstlisting}

A tabela abaixo mostra os métodos disponíveis para operar em listas:
\begin{table}[h!]
    \centering
    \begin{tabular}{l l}
    {\tt append({\it element})}     & Anexa {\it element} ao final da lista  \\
    {\tt extend({\it other\_list})}     &  Estende a lista com os elementos de {\it other\_list}\\
    {\tt index({\it element})} & Retorna o índice mais baixo da lista que contém {\it element} \\
    {\tt insert({\it index, element})} & Insere {\it element} no índice {\it index} \\
    {\tt pop({\it index})} & Remove o elemento de índice {\it index}+1\\
    {\tt reverse()} & Reverte a ordem da lista\\
    {\tt remove({\it element})} & Remove a primeira ocorrência de {\it element}\\
    {\tt sort()} & Ordena a list\\
    {\tt count({\it element})} & Conta o número de ocorrências de {\it element}
    \end{tabular}
    \caption{Alguns métodos disponíveis para operar em listas.}
    \label{tb:list-methods}
\end{table}

\section{Instruções de Controle}

Poucos programas de computador são executados de forma puramente sequencial, uma instrução após outra na sequência escrito no código-fonte. É comum que durante a execução do programa, dados sejam inspecionados e blocos de código executados a depender de
algum teste realizado nestes dados. Instruções de controle são instruções que permitem que um programa siga caminhos diferentes dependendo de algum evento. Essas instruções fazem o papel análogo a instruções da vida real do tipo “Se você está com fome, coma.” ou ainda “Enquanto a luz estiver vermelha, não entre.”  Todas essas instruções têm a mesma estrutura básica: (a) a própria instrução: ``se'' ou ``Enquanto'', (b) um  ``condicional'', que é uma afirmação que deve ser avaliada como verdadeira (True) ou falsa (True): ``você está com fome'' ou ``A luz está vermelha''. E há a ação a ser executa: ``coma'' ou ``não entre''. 

Nessa seção, discutiremos 3 instruções de controle do Python, são elas:\\ 
\begin{center}
    {\tt if ... elif ... else}, {\tt while} e {\tt for}.
\end{center}
Antes de explorarmos como essas instruções funcionam vamos entender um pouco mais sobre condicionais.

\subsection{Condicionais}

Um condicional é qualquer coisa que o Python possa avaliadar como  True (verdadeiro) ou falso. Geralmente um condicional será uma expressão de uma relação entre dados que são comparados usando operadores de comparação como {\tt ==, !=, <, <=, >, >=} . Veja os seguintes exemplos:
\begin{lstlisting}[language=Python]
print(1<2)
print('a' in 'Fisica')
print('b' not in 'Fisica')
print(22/7 < 3.14)
print(10**2 == 100.)
print([1,2,3] != [1,2,'tres'])
\end{lstlisting}
Condicionais podem também ser combinados usando operadores booleanos {\tt and, or} e {\tt not}. Operadores booleanos tem a menor ordem de precedência em todo o Python. A tabela abaixo mostra como esses operadores booleanos agem
\begin{table}[h!]
\begin{minipage}{.36\textwidth}
    \centering
    {\tt 
    \begin{tabular}{c c c c}
     True & and & True & -> True\\
     True & and & False & -> False \\
     False & and & True & -> False \\
     False & and & False & -> False
    \end{tabular}}
    \end{minipage}
    \begin{minipage}{.36\textwidth}
    \centering
    {\tt 
    \begin{tabular}{c c c c}
     True & or & True & -> True\\
     True & or & False & -> True \\
     False & or & True & -> True \\
     False & or & False & -> False
    \end{tabular}}
    \end{minipage}
    \begin{minipage}{.3\textwidth}
    \centering
    {\tt 
    \begin{tabular}{c c c c}
      & not & True & -> False\\
      & not & False & -> True \\
     \end{tabular}}
    \end{minipage}
    \caption{Algebra Booleana}
    \label{tab:boolean}
\end{table}

\subsection{if ... elif ... else}

A instrução de controle mais básica em Python\footnote{ou qualquer outra linguagem de computador}, é a instrução equivalente ao ``se''. Ele permite que você diga ao computador o que fazer se alguma condição é satisfeita. A sintaxe é a seguinte:
\begin{lstlisting}[language=Python]
if <condicional 1>:
    <instrucao 1>
    <instrucao 2>
    ...
elif <condicional 2>:
    <instrucao 3>
    <instrucao 4>
    ...
else:
    <instrucao 5>
\end{lstlisting}
Observe a indentação do código, i.e. os espaços em branco (um Tab) entre {\tt if ... elif ... else}. Em Python, esses espaços em branco definem que o grupo de comandos deve ser executado caso o condicional seja True. Ou seja a indentação não é opcional. A identação serve para informar ao Python, qual bloco de instruções é deve ser executado se aquele condicional for verdadeiro. As instruções {\tt elif} (ou se) e {\tt else} (``ou então'') estendem a instrução {\tt if}. A instrução {\tt elif}, é uma abreviação para “else if” adiciona outro {\tt if} que é testado se e somente se o primeiro condicional for falso. Você pode utilizar quantos {\tt elif} forem necessários, os condicionais serão testados na ordem em que aparecerem. A instrução {\tt else}, é executada  se nenhuma das instruções {\tt elif} anteriores, ou a inicial {\tt if}, for verdadeira.

{\bf Exemplo:} No calendário gregoriano, um ano é bissexto se for divisível por 4 com a exceção de que os anos divisíveis por 100 não são bissextos, a menos que também sejam
divisíveis por 400. O programa Python a seguir determina se ano é bissexto.
\begin{lstlisting}[language=Python, frame=lines,basicstyle=\footnotesize, caption={Determinando se um ano é bissexto.}, label={lst:bissexto}]
ano = int(input('Qual o ano?')

if not ano % 400:
    is_leap_year = True
elif not year % 100:
    is_leap_year = False
elif not year % 4:
    is_leap_year = True
else:
    is_leap_year = False
if   is_leap_year = True
    print('O ano ', year, ' e bissexto')
else:
    print('O ano ', year, 'nao e bissexto')
\end{lstlisting}

\subsection{while}

A instrução while é usada para repetir um bloco de comandos até que uma condição
deixe de ser satisfeita. Considere o exemplo abaixo:
\begin{lstlisting}[language=Python]
i = 0
while i < 10:
    i += 1
    print(i, end=',')
print('fim')
\end{lstlisting}
Cada vez que o bloco de instruções do {\tt while} é executado, o contador $i$ (que começa em 0), é acrescido de 1 e seu valor é impresso. Esse bloco será executado até que $i$ tenha o valor $10$, quando o Python sai do loop e executa o comando {\tt print(fim}).

Podemos combinar loops {\tt while} com {\tt if ... elif...else} para obtermos decisões mais complexas. Veja o exemplo a seguir:

{\bf Exemplo:} Em 1937, o matemático alemão Lothar Collatz, propôs a seguinte sequência de inteiros positivos: O primeiro termos da sequência é $c_1 =n$, onde $n$ é um número inteiro positivo. Dado o $c_k$, o $k$-ésimo termo da sequência, o termo seguinte é obtido fazendo
\[a_{k+1} =\left\{\begin{array}{cl} a_k/2 & \textrm{se } a_k\textrm{ é par}\\
3a_k+1 & \textrm{se } a_k \textrm{ é ímpar}
\end{array}\right.\]
Collatz conjecturou que qualquer que seja o inteiro inicial $c_1$ a sequência sempre termina em $1$. Até o momento em que escrevo essas notas (2022), a Conjectura de Collatz nunca havia sido provada, permanecendo como um problema em aberto (para mais detalhes veja a Ref. \cite{collatzconjecture}. Nesse exemplo, iremos obter a sequência de Collatz para um inteiro positivo qualquer. Tente resolver antes de checar uma possível solução abaixo.

\begin{lstlisting}[language=Python, frame=lines,basicstyle=\footnotesize, caption={Testando a conjectura de Collatz}, label={lst:Collatz}]
num = int(input('Qual o inteiro positivo inicial?'))
print('A sequencia de Collatz para', num)
while num != 1:
    if num % 2 == 0:
        num = int(num/2)
        print(num, end=',')
    else:
        num = int(3*num+1)
        print(num, end=',')
\end{lstlisting}

Loops {\tt while} podem ser estendidos usando alguma palavras chave:

\paragraph{continue} A instrução {\tt continue} move a execução do programa para o topo
o bloco {\tt while} sem terminar a parte do bloco seguinte a instrução continue.

\paragraph{break} A instrução {\tt break} interrompe a execução do loop e recomeça o código diretamente para a linha seguinte ao bloco {\tt while}. Em outras palavras, ele ``sai'' do loop.

\paragraph{else} Um comando {\tt else} no final de um bloco {\tt while} é usado para delinear um bloco de código que é executado depois que o bloco {\tt while} termina, mas
o código neste bloco não é executado se o bloco {\tt while} for encerrado via
um comando de pausa.

O exemplo a seguir deve esclarecer o uso dessas instruções.

{\bf Exemplo:} Você precisa escrever um programa que teste se um número é
primo ou não. O programa deve pedir o inteiro para testar, em seguida, imprima uma mensagem informando o primeiro fator encontrado ou informando que o número é primo. Tente você mesmo antes de examinar o exemplo abaixo:

\begin{lstlisting}[language=Python, frame=lines,basicstyle=\footnotesize, caption={Testando se um número é primo}, label={lst:isprime}]
Number = int(input('Qual inteiro iremos testar?'))
TestNumber = 2
while TestNumber < Number :
    if Number % TestNumber == 0 :
        print(Number , 'e divisivel por' , TestNumber , end='.')
        break
    else:
        TestNumber += 1
else:
    print(Number , 'e primo', end ='.')
\end{lstlisting}
Esta não é a forma mais eficiente de determinar se um número inteiro muito grande é primo.

\subsection{for}
O loop {\tt for} itera sobre os itens em uma sequência, repetindo o bloco de loop uma vez
por item. A sintaxe mais básica é a seguinte:
\begin{lstlisting}[language=Python]
for <iterador> in <tipo sequencial>
    <instrucao 1>
    <instrucao 2>
    ...
\end{lstlisting}
Cada vez que passar pelo loop, o valor do {\tt iterador} será o valor do
próximo elemento em {\tt <tipo sequencial>} . Vejamos o exemplo abaixo, 
\begin{lstlisting}[language=Python]
lista = [1,'a',[1,2]]
index = 0
for t in lista:
    print('o elemento', index, '=', t)
    index += 1
\end{lstlisting}
o código imprime cada um dos elementos de {\tt lista}.
Você pode usar qualquer tipo sequencial, mas tipos imutáveis são preferíveis para se evitar alterar a sequência que esta controlando o loop. Por exemplo, o exemplo abaixo vai gerar um loop infinito:
\begin{lstlisting}[language=Python]
lista = [1,'a',[1,2]]
index = 0
for t in lista:
    print('o elemento', index, '=', t)
    lista += index*[t]
    index += 1
\end{lstlisting}

O exemplo abaixo mostra como podemos usar uma string para controlar o {\tt for}.
\begin{lstlisting}[language=Python]
letras = 0
for t in 'Palavra':
    letras +=1
\end{lstlisting}
No cálculos numéricos, é mais comum usar o comando for sobre um intervalo numérico gerado com {\tt range}
\begin{lstlisting}[language=Python]
N, S = 100, 0
for t in range(0,N,1):
    S += t 
print(S)    
\end{lstlisting}

O exemplo abaixo mostra como gerar a sequência de Fibonacci e aproximar a razão áurea.
\begin{lstlisting}[language=Python, frame=lines,basicstyle=\footnotesize, caption={Sequência de Fibonacci e a Razão Áurea }, label={lst:fibonacci}]
N = 100
fibonacci = [1, 1]

type(fibonacci)
for n in range(2,N):
    fibonacci.append(fibonacci[n-1]+fibonacci[n-2])
print(fibonacci)
print('Razao Aurea aproximadamente', fibonacci[n]/fibonacci[n-1])
\end{lstlisting}

A instrução {\tt for} também permite o uso das mesmas palavras-chave usadas para {\tt while}. Além, disso o Python fornece uma sintaxe muito útil e concisa para criar e manipular tipos sequenciais. Quando aplicada a listas essa sintaxe é chamada de {\it List Comprehensions}. A ideia é usar instruções {\tt for} e {\tt if} no interior da indicação de uma lista. A sintaxe é
\begin{lstlisting}[language=Python]
lista_1 = [ <expressao> for <iterador> in <tipo sequencial]
lista_2 = [<expressao> if <condicional> else <expressao> 
        for <iterador> in <tipo sequencial>]
\end{lstlisting}

O uso de {\it List Comprehensions} deve ficar mais claro nos exemplos abaixo:

{\bf Exemplo:} Suponha que você tenha uma lista de medidas de comprimento feitas em polegadas. Precisamos converter essas medidas para centímetros (1 polegada = 2.54 cm).
\begin{lstlisting}[language=Python]
lista_de_medidas = [1.1, 1.3, 1.75, 2.1, 9.1, 10.2, 9.8 ]
medidas_cm = [2.54*medida for medida in lista_de_medidas]
\end{lstlisting}

{\bf Exemplo:} Crie uma lista com os números entre 0 e 100 que são divisíveis por 6, mas não são divisíveis por 5.
\begin{lstlisting}[language=Python]
max = 100//6
numeros=[6*n for n in range(max) if (not 6*n % 5 ==0)]
print(numeros)
\end{lstlisting}

\section{Funções}

Uma função é um bloco de código que recebe seu próprio nome para que possa ser
usado repetidamente por várias partes de um programa. Nesse sentido uma função pode ser um código para realizar um cálculo matemático, ou um código para fazer algo, como desenhar um gráfico ou salvar uma lista de números. No Python, a primeira linha de uma função é definida com a palavra-chave {\tt def} (vem de {\it definition}) seguido pelo nome da função, a lista de argumentos e dois pontos(:). As demais linhas contém as operações que compõem a função, que ficam em um bloco de código indentado. Lembre que no Python, a indentação funciona como um organizador para que o Python saiba a qual parte do código aquele bloco pertence. A sintaxe basica de uma função é a seguinte
\begin{lstlisting}[language=Python]
def <nome>(<argumentos>):
    <codigo da funcao>
\end{lstlisting}
O {\tt<nome>} estabelece o nome pelo qual a função será chamada. As mesmas regras para se nomear uma variável (ver \ref{sc:naming-var}, valem para nomear funções. As funções no Python, podem possuir argumentos, de forma análoga a suas análogas em matemática.  Esses argumentos são uma lista de coisas que a função precisa para fazer seu trabalho. Os argumentos vem dentro de parênteses imediatamente após o nome da função. O código indentado será executado sempre que a função for chamada e usará os argumentos dados entre parênteses como parâmetros.
As funções também podem retornar valores usando a palavra-chave {\tt return} seguida por uma expressão  a ser devolvida. Neste caso a syntaxe é
\begin{lstlisting}[language=Python]
def <nome>(<argumentos>):
    <codigo da funcao>
    return <retorno1>, <retorno2>, ..., <retorno3>
\end{lstlisting}

{\bf Exemplo:} Vamos escrever uma função que soma os dígitos de um número. Tente você antes
de ver o exemplo abaixo.
\begin{lstlisting}[language=Python]
def soma_digitos(n):
    n_name = str(n)
    s = 0
    for i in n_name:
        s += int(i)  
    return s
\end{lstlisting}

A função também pode retornar múltiplos valores. Vejo o exemplo

\begin{lstlisting}[language=Python]
def energia_momento(m,v):
    K = (1/2)*m*v**2
    p = m * v
    return K, p
\end{lstlisting}

Em várias situações é interessante definir argumentos com valores padrão. Em Python, eles são conhecidos como argumentos de palavras-chave, e nesse caso apontar o valor dos argumentos passa a ser opcional, i.e. a função usa o argumento padrão quando um novo valor não é usado. Quando os argumento são passados com palavras-chave, eles podem ser chamados em qualquer ordem. Os argumentos de palavra-chave são definidos pelo nome do argumento (a palavrachave), um sinal de igual ( = ), e o valor padrão que é usado se o argumento não for fornecido quando a função é chamada. A sintaxe básica é a seguinte
\begin{lstlisting}[language=Python]
def <name>s(<key word1> = <val1>, ..., <key wordn> = <valn>):
    <codigo da funcao>
\end{lstlisting}




\section{Bibliotecas: o Básico}

Uma das coisas mais úteis do Python é a existência de inúmeras bibliotecas que permitem adicionar novas funcionalidades ao sistema. Sem elas o Python básico é apenas um linguagem de programação e teríamos que escrever códigos até para coisas bastante simples. Por exemplo, sozinho o Python não possui funções trigonométricas embutidas, nem conhece o valores de $\pi$ e $e$. Mas isso pode ser facilmente resolvido importando a biblioteca {\bf math}. Isso é feito com o comando {\tt import math}

Os comandos {\tt import}são geralmente colocados no início do código, mas essa é meramente uma questão de conveniência. Uma vez que o pacote/biblioteca tiver sido importado, todas as funções no {\bf math} estão disponíveis e podem ser acessadas usando a sintaxe {\tt math.<function-name>}. Por exemplo

\begin{lstlisting}[language=Python]
import math
x = math.p i/3.0
print(x, math.sin(x), math.cos(x), math.tan(x))
\end{lstlisting}

Existem muitas outras funções e constantes no pacote {\bf math}. Você pode saber quais usando 

\begin{lstlisting}[language=Python]
help(math)
\end{lstlisting}

Algumas vezes é
 útil para apenas importar elementos individuais de um pacote em vez do pacote inteiro. Por exemplo para que pudéssemos nos referir a {\tt sin(x)} ao invés de {\tt math.sin(x)}.
 
 \begin{lstlisting}[language=Python]
from math import sin
\end{lstlisting}

Outras vezes você pode importar todas as funções em um pacote (e novamente se referir a função pelo nome):

 \begin{lstlisting}[language=Python]
from math import *
\end{lstlisting}

Uma outra opção é dar um apelido curto para o pacote durante a importação. Por exemplo, durante todos esse texto utilizaremos um pacote bastante útil para a produção de gŕaficos chamado {\bf matplotlib.pyplot} é conveniente usar
\begin{lstlisting}[language=Python]
import matplotlib.pyplot as plt
\end{lstlisting}
Com isso os comandos do {\bf matplotlib.pyplot} são chamados usando {\tt plt.<function-name>}. Vamos usar essa oportunidade para construir nosso primeiro gráfico. Vamos plotar os pontos $(0,0), (1,2), (3,1)$. Para isso (incluindo o comando de importação do {\bf matplotlib.pyplot}, que não será necessário caso você já tenha feito a importação)

\begin{lstlisting}[language=Python]
import matplotlib.pyplot as plt

plt.scatter([0,1,3],[0,2,1])
plt.show()
\end{lstlisting}
Você deve obter algo como mostrado na imagem \ref{fig:first-plot}

\begin{figure}
    \centering
    \includegraphics{Images/first plot.png}
    \caption{Plot dos pontos $(0,0), (1,2), (3,1)$. }
    \label{fig:first-plot}
\end{figure}

Algumas bibliotecas serão corriqueiramente utilizadas em todo este texto. São elas

\begin{itemize}
    \item {\bf numpy:} O Numerical Python, é uma biblioteca que permite manipular objetos conhecidos como arrays, que a grosso modo são matrizes multidimensionais. Além disso, o Numpy possui uma coleção de rotinas para processar esses arrays. Discutimos vários usos do Numpy no Apêndice \ref{a:numpy}
    \item {\bf scipy:} O Scientific Phyton contém várias ferramentas dedicadas a problemas comuns em computação científica. Seus diferentes sub-módulos correspondem a diferentes aplicações, tais como interpolação, integração, otimização, processamento de imagens, estatísticas, funções especiais, etc. Em geral, antes de implementar uma rotina, vale a pena verificar se o processo desejado não está implementado em SciPy. E nesse caso você não precisa reinventar a roda. Vale lembrar que o scipy utliza o numpy.
    \item {\bf matplotlib:} O Matplotlib é uma biblioteca com a funcionalidade de criar gráficos 2D. Em palavras o matplotlib usa o numpy para transformar dados em gráficos. O módulo pyplot do matplotlib permite operar de maneira análoga ao software comercial MATLAB (que talvez seja a ferramenta mais utilizada em simulações numéricas).
    \item {\bf sympy:} O Symbolic Python é uma biblioteca que fornece ferramentas para computação algébrica de maneira análoga a softwares comerciais como o Mathematica e o Maple. A computação algébrica ou computação simbólica  permite realizar várias tarefas matemáticas simbolicamente e obter respostas exatas para muitos problemas matemáticos, como a fatoração de números inteiros e polinômios, operações com matrizes, resolução de sistemas lineares e não lineares de equações, operações com números complexos, simplificações de expressões, cálculo de limites, derivadas e integrais, resolução de equações diferenciais.
\end{itemize}

Você também pode construir suas próprias bibliotecas. Isso é mais fácil do que você pode imaginar, de fato todo programa Python é um biblioteca! Qualquer código em Python quando salvo programa terminando '.py' em seu nome de arquivo (cuidado o Jupyter-notebook usa .ipynb) pode ser importado por qualquer outro programa Python. Apenas use {\tt from <filename> import <function(s)>}. Imagine por exemplo que você criou um código chamado {\tt gavitation.py}, esse código inclui um função {\tt grav-field} que calcula o campo gravitacional de um objeto. Se você quiser utilizar essa função em um novo código basta fazer {\tt from gravitation impor grav-field}.

Na internet você pode encontrar diversas bibliotecas gratuitas. A depender da área que você estudando vale a pena se familiarizar com as bibliotecas que outros pesquisadores escreveram para facilitar a totina de pesquisas naquela área. Algumas outras bibliotecas adicionam amenidades ao Python. Um exemplo é a {\bf tqdm}. Imagine que seu código leva bastante tempo para ser computado, a   {\bf tqdm} permite construir fácilmente uma barra de progresso para algorítimo. Veja o exemplo:

\begin{lstlisting}[language=Python]
from tqdm.notebook import tqdm
from time import sleep

for i in tqdm(range(10)):
    sleep(3)
\end{lstlisting}

Uma última coisa a se considerar é que sempre que você importa um pacote, ele sobrescreve qualquer coisa com o mesmo nome. Isso pode causar problemas. Por exemplo, tanto o {\bf math} quanto o {\bf numpy}
possuem funções trigonométricas. Mas as funções trigonométricas do pacote {\bf math} apenas atuam em números, enquanto as funções do numpy são capazes de operar em matrizes inteiras de uma só vez. Com isso se você importar primeiro o {\bf numpy} e em seguida o {\bf math}, o comando {\tt sin} é o comando do {\bf math} e não consegue operar em arrays do {\bf numpy.} Compare os dois códigos abaixo e veja que o primeiro apresenta um erro.

\begin{lstlisting}[language=Python]
#Importando o primeiro o numpy
from numpy import *
from math import *

x = arange(10)*pi/10
y = sin(x)
\end{lstlisting}

\begin{lstlisting}[language=Python]
#Importando o primeiro o math
from math import *
from numpy import *

x = arange(10)*pi/10
y = sin(x)
\end{lstlisting}

Se você realmente precisas usar simultâneamente o {\bf math} e o {\bf numpy} seria melhor usar algo como

\begin{lstlisting}[language=Python]
#Importando o primeiro o math
import numpy as np
import math

x = np.arange(10)*np.pi/10
y = np.sin(x)

z = math.sin(np.pi/2)
\end{lstlisting}

\section{Gráficos Simples}

Como vimos o {\bf matplotlib} é uma ferramenta útil para construção de gráficos. Ela não é a única, mas será a que mais utilizaremos nesse texto. Os gráficos do matplotlib são criados apartir de arrays, o que torna o matplotlib na prática dependente do {\bf numpy}. Gráficos comuns podem ser criados de maneira simples e com alta qualidade. 

\begin{itemize}
    \item pylab: conjunto de funções disponíveis em matplotlib.pylab que permite a geração de código similar ao MATLAB.
    \item frontend ou API: conjunto de classes que realizam o trabalho pesado, criando as figuras, texto, linhas etc. Essa é uma interface abstrata que independe da saída.
    \item backends: conjunto de funções que dependem do dispositivo de saída (display). Por exemplo, PS para gráficos em PostScript, SVG gera gráficos em Scalable Vector Graphics, Agg cria figuras no formato PNG, GTK permite que os gráficos sejam incluídos em aplicações GTK+, e assim para PDF, WxWidgets, Tkinter, etc
\end{itemize}

O conjunto de funções disponível em {\tt matplotlib.pyplot} permitem que você crie uma figura, uma área para exibir o gráfico na figura, desenhe linhas na área do gráfico, decore o gráfico com rótulos, etc. A sintaxe utilizada é semelhante ao MATLAB.

Cada função do pyplot muda uma parte da figura, por exemplo, cria uma figura, cria uma área dentro da figura para desenhar um gráfico, desenha linhas em um gráfico, decora o gráfico com rótulos, etc. No pyplot, vários estados são preservados após a chamada de uma função dentro de um contexto, simplificando assim o seu trabalho sobre a figura ou área de desenho atuais. Assim, você pode ter uma figura complexa formada por várias áreas de desenho distintas, e o pyplot mantém para você informações sobre para cada área de desenho. Vejamos o exemplo abaixo: 

\begin{lstlisting}[language=Python]
import numpy as np
import matplotlib.pyplot as plt


data1 = [10,5,2,4,6,8]
data2 = [ 1,2,4,8,7,4]
x = 10*np.array(range(len(data1)))

plt.plot( x, data1, 'go') # green bolinha
plt.plot( x, data1, 'k:', color='orange') # linha pontilha orange

plt.plot( x, data2, 'r^') # red triangulo
plt.plot( x, data2, 'k--', color='blue')  # linha tracejada azul

plt.axis([-10, 60, 0, 11])
plt.title("Um Plot com PyPlot")

plt.grid(True)
plt.xlabel("eixo x")
plt.ylabel("eixo y")
plt.show()
\end{lstlisting}


A Fig. \ref{fig:anatomy}, que foi gerada com o código abaixo, mostra as diversas partes de uma figura do matplotlib. Alguns elementos são auto-explicativos.

\begin{lstlisting}[language=Python, frame=lines,basicstyle=\footnotesize, caption={Código com os elementos de uma figura do matplotlib}, label={lst:fig-anatomy}]
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import AutoMinorLocator, MultipleLocator

np.random.seed(19680801)

X = np.linspace(0.5, 3.5, 100)
Y1 = 3+np.cos(X)
Y2 = 1+np.cos(1+X/0.75)/2
Y3 = np.random.uniform(Y1, Y2, len(X))

fig = plt.figure(figsize=(8, 8))
ax = fig.add_subplot(1, 1, 1, aspect=1)



def minor_tick(x, pos):
    if not x % 1.0:
        return ""
    return f"{x:.2f}"

ax.xaxis.set_major_locator(MultipleLocator(1.000))
ax.xaxis.set_minor_locator(AutoMinorLocator(4))
ax.yaxis.set_major_locator(MultipleLocator(1.000))
ax.yaxis.set_minor_locator(AutoMinorLocator(4))
# FuncFormatter is created and used automatically
ax.xaxis.set_minor_formatter(minor_tick)

ax.set_xlim(0, 4)
ax.set_ylim(0, 4)

ax.tick_params(which='major', width=1.0)
ax.tick_params(which='major', length=10)
ax.tick_params(which='minor', width=1.0, labelsize=10)
ax.tick_params(which='minor', length=5, labelsize=10, labelcolor='0.25')

ax.grid(linestyle="--", linewidth=0.5, color='.25', zorder=-10)

ax.plot(X, Y1, c=(0.25, 0.25, 1.00), lw=2, label="Plot Azul", zorder=10)
ax.plot(X, Y2, c=(1.00, 0.25, 0.25), lw=2, label="Plot Vermelho")
ax.plot(X, Y3, linewidth=0,
        marker='d', markerfacecolor='g', markeredgecolor='k')

ax.set_title("Elementos de uma figura do Matplotlib", fontsize=20, verticalalignment='bottom')
ax.set_xlabel("Label do eixo X")
ax.set_ylabel("Label do eixo Y")

ax.legend(loc="upper right")



def circle(x, y, radius=0.15):
    from matplotlib.patches import Circle
    from matplotlib.patheffects import withStroke
    circle = Circle((x, y), radius, clip_on=False, zorder=10, linewidth=1,
                    edgecolor='black', facecolor=(0, 0, 0, .0125),
                    path_effects=[withStroke(linewidth=5, foreground='w')])
    ax.add_artist(circle)


def text(x, y, text):
    ax.text(x, y, text, backgroundcolor="white",
            ha='center', va='top', weight='bold', color='orange')


# Minor tick
circle(0.50, -0.10)
text(0.50, -0.32, "Label do tick menor")

# Major tickMinor tick label
circle(-0.03, 4.00)
text(0.03, 3.80, "Tick maior")

# Minor tick
circle(0.00, 3.50)
text(0.00, 3.30, "Tick menor")

# Major tick label
circle(-0.15, 3.00)
text(-0.15, 2.80, "Label do Tick maior")

# X Label
circle(1.75, -0.30, radius=0.17)
text(1.75, -0.50, "Label do eixo x")

# Y Label
circle(-0.3, 1.75, radius=0.17)
text(-0.16, 1.57, "Label do eixo y")

# Title
circle(1.60, 4.13)
text(1.60, 3.93, "Titulo")

# Blue plot
circle(1.75, 2.80)
text(1.75, 2.60, "Linha\n(line plot)")

# Red plot
circle(1.20, 0.60)
text(1.20, 0.40, "Linha\n(line plot)")

# Scatter plot
circle(3.20, 1.75)
text(3.20, 1.55, "Marcadores\n(scatter plot)")

# Grid
circle(3.00, 3.00)
text(3.00, 2.80, "Grid")

# Legend
circle(3.70, 3.80)
text(3.70, 3.60, "Legenda")

# Axes
circle(0.5, 0.5)
text(0.5, 0.3, "Axes")

# Figure
circle(-0.3, 0.65)
text(-0.3, 0.45, "Figura")


ax.annotate('Spines', xy=(4.0, 0.35), xytext=(3.3, 0.5),
            weight='bold', color=color,
            arrowprops=dict(arrowstyle='->',
                            connectionstyle="arc3",
                            color=color))

ax.annotate('', xy=(3.15, 0.0), xytext=(3.45, 0.45),
            weight='bold', color=color,
            arrowprops=dict(arrowstyle='->',
                            connectionstyle="arc3",
                            color=color))


plt.show()

\end{lstlisting}

\begin{figure}
    \centering
    \includegraphics[scale=0.7]{Images/anatomy.png}
    \caption{Elementos de uma figure do Matplotlib. Fonte: matplotlib.org}
    \label{fig:anatomy}

\end{figure}

\begin{enumerate}
    \item {\bf Figura}: É o elemento {\tt figure} que controla a figura como um todo. O Este controla todos os demais elementos, como os Axes, Eixos e outros elementos chamados coletivamente de ``Artists''. O tutorial do matplotlib descreve este elemento  como sendo a tela (em branco) de uma pintura .
    \item {\bf Axes}: O Axes corresponde a região da imagem com os dados preenchidos (a pintura). Cada figura pode conter diversos Axes. Cada Axes pode conter dois Eixos ou Axis (ou 3 axis, no caso de um gráfico em 3 dimensões), que é o elemento que determina os limites dos dados do gráfico. O elemento axes representam um plot individual na figura.
    \item {\bf Eixos e seus Labels:} Os Axis determinam os limites dos gráficos, os ticks (major and minor) e os tickslabels dos eixos. Não confunda axes com axis. O elemento axis se refere aos eixos x e y (e z, se for um gráfico em 3D) do plot.
    \item {\bf Artists mais comuns:} m Artist é basicamente tudo que você vê em um gráfico (inclusive os Axis, Axes e Figure). Então os objetos de texto, linhas, coleções, etc, são todos da classe {\tt Artist}, e quando a figura é renderizada, todos os artistas são desenhados na {\tt figure}. Alguns dos objetos mais comuns são {\tt plot} que desenha uma linha correspondente ao gráfico, o {\tt scatter} que desenha pontos, {\tt title} que coloca título no gráfico, {\tt grid} que desenha uma grade no gráfico. 
\end{enumerate}


\section{Lendo dados de arquivos}


Em várias áreas da Física é necessário possuir conhecimentos em manipulação de arquivos, seja para armazenar resultados de um experimento ou até mesmo para receber arquivos como parâmetro para a execução de uma simulação. Neste seção abordaremos como ler informações armazenadas em aquivos. Existem centenas de formatos para os dados em um arquivo, e isso é usualmente representado pela extensão do nome do arquivo. Nessa abordagem introdutória, vamos discutir arquivos {\tt .txt}.


Para abrir um arquivo  {\tt .txt} com Python utilizamos o comando {\tt open}. A sintaxe é {\tt open(<arquivo>, <modo>)}, onde {\tt <arquivo>} é a identificação do arquivo (i.e. localização e o nome do arquivo) que será aberto, {\tt <modo>} a forma de abertura do arquivo. Essa função também pode ser utilizada para criar novos arquivos, sendo o que diferencia abertura de criação é o valor inserido no campo “modo” durante a chamada da função.

Os valores mais comumente utilizados para {\tt modo} são:
\begin{itemize}
    \item {\tt 'r'}: Somente leitura. Este é o modo padrão, i.e. se a opção modo for omitida o arquivo será aberto, você poderá ler os dados nele contidos, mas não poderá altera-los.
    \item {\tt 'w'}: Escrita. Caso o arquivo já exista, ele será apagado e um novo arquivo vazio será criado. Caso o arquivo não exista, o Python criará um arquivo vazio.
    \item {\tt 'a'}: Acrescentar. Adiciona o novo conteúdo ao fim do arquivo.
\end{itemize}

Depois de aberto, podemos realizar a leitura dos dados contidos no arquivo usando as funções: {\tt read()}, {\tt readline()} ou {\tt readlines()}. A função {\tt read(n)} lê até $n$ bytes do arquivo. Caso o valor não seja informado, a função lê o arquivo inteiro. A função {\tt readline()} retorna uma string contendo a primeira linha do arquivo. Por fim, a função {\tt readlines()} retorna uma lista de strings, sendo cada elemento uma linha do arquivo. Para entendermos, o funcionamento, vamos pegar o arquivo {\tt br-sem-acentos.txt} na página do github destas notas e salva-lo no mesmo diretório em executaremos o nosso código. Depois disso vamos abrir este arquivo no modo somente leitura. Veja o exemplo:
\begin{lstlisting}[language=Python]
file = open('br-sem-acentos.txt', 'r')
file.read()
\end{lstlisting}
O resultado deve ser uma estranha lista de palavras separadas por \lstinline{'\n'}. O \lstinline{'\n'} indica uma quebra de linha (``new line''). Podemos ver o efeito deste caractere de formatação com o comando {\tt print(f.read()}. Como dissemos o comando {\tt readlines()} lê as linhas do arquivo e constrói uma lista de strings com ela. Ou seja cada palavra separada por \lstinline{'\n'} será um elemento da lista. Como teste tentemos:
\begin{lstlisting}[language=Python]
words=file.readlines()
print(words[0:20])
\end{lstlisting}
O resultado são uma lista com as 20 primeiras palavras do arquivo. Note que ainda se mantém o \lstinline{'\n'}. Podemos eliminar esse caractere especial, fazendo:
\begin{lstlisting}[language=Python]
words = [ (word.replace('\n','')).lower() for word in words]
print(words[0:20])
\end{lstlisting}

Uma vez criada a lista de palavras, podemos utiliza-la para obter dados estatísticos sobre as palavras como no exemplo abaixo.

\begin{lstlisting}[language=Python, frame=lines,basicstyle=\footnotesize, caption={Estatísticas das palavras da Lingua Portuguesa}, label={lst:est-palavras}]
import string
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm

letters = string.ascii_lowercase

f = open('br-sem-acentos.txt', 'r')
words = f.readlines()
words = [ (word.replace('\n','')).lower() for word in words]


# Mediar Frequencia das Letras no conjunto de palavras
frequencia = np.zeros(len(letters))
for n,l in enumerate(tqdm(letters)):
    for word in words:
        frequencia[n] += word.count(l)
frequencia = frequencia/frequencia.sum()

# Medir frequencia dos comprimentos
comp_list = [len(word) for word in words]
max_size = np.array(comp_list).max()
comp_freq = [comp_list.count(n) for n in range(1,max_size)]

# Contar a frequencia das Letras em cada Posicao
freq_1a_letra = np.zeros(len(letters))
freq_f_letra = np.zeros(len(letters))

for l in letters:
    temp_words_1 = [word for word in words if word[0]==l]
    temp_words_f = [word for word in words if word[len(word)-1]==l]
    freq_1a_letra[letters.index(l)] = len(temp_words_1)
    freq_f_letra[letters.index(l)] = len(temp_words_f)
    
freq_1a_letra = freq_1a_letra/freq_1a_letra.sum()
freq_f_letra  = freq_f_letra/freq_f_letra.sum()

# Contar o numero de Vogais e a frequencia
def conta_vogais(word):
    return (word.count('a')+word.count('e')+word.count('i')
            +word.count('o')+word.count('u')

n_vogais = [conta_vogais(word) for word in words]
n_vog_freq = [n_vogais.count(i)/len(words) for i in set(n_vogais)]

# Criar Plots

plt.figure(figsize=(13, 13))
# Plot Frequencia das Letras
plt.subplot(2, 2, 1)
plt.bar( list(letters), frequencia, label='Frequencia Total das Letras',
        width=.5, align='center')
plt.bar( list(letters), freq_1a_letra, label='Frequencia como a 1a Letra',
        width=.5, align='edge', alpha = 0.4)
plt.bar( list(letters), freq_f_letra, label='Frequencia como a ultima Letra',
        width=.5, align='edge', alpha = 0.4)
plt.title('Frequencia das Letras')
plt.legend(prop={'size': 8})

# Plot Frequencia dos Comprimentos
plt.subplot(2, 2, 2)
plt.bar( np.arange(1,max_size), comp_freq)
plt.xlabel('Comprimento')
plt.ylabel('Frequencia')
plt.title('Frequencia do Comprimento das Palavras')


#Frequencia do numero de Vogais
plt.subplot(2, 2, 3)
plt.bar(np.arange(0,12), n_vog_freq)
plt.xlabel('Numero de Vogais')
plt.ylabel('Frequencia')
plt.title('Frequencia do # de vogais em uma palavra')

#Comprimento x numero de vogais
plt.subplot(2, 2, 4)
plt.scatter(n_vogais, comp_list)
plt.xlabel('Numero de Vogais')
plt.ylabel('Frequencia')
plt.title('Frequencia do # de vogais em uma palavra')

plt.show()

\end{lstlisting}

A saída deve ser análoga a Fig. \ref{fig:letras}.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{Images/letras.png}
\caption{Estatísticas das palavras da Língua Portuguesa}\label{fig:letras}
\end{figure}



\section{Exercícios}
\begin{enumerate}
    \item Comente com $\#$ os códigos dados como exemplo nesse capítulo, indicado o que cada linha ou bloco instrui o computador a fazer.
    \item Use list Comprehensions para:
    \begin{enumerate}
        \item Construir uma lista com todos os quadrados perfeitos entre 100 e 200.
        \item Construir uma lista com apenas os ímpares da lista \\{\tt numbers = [3,5,45,97,32,22,10,19,39,43]}
        \item Contar o número de espaços em branco em uma {\tt string}.
    \end{enumerate}
    \item Escreva um programa que pede para o usuário escrever um número inteiro entre $0$ e $999.999$, e então escreve esse número por extenso.
    \item Escreva uma função Python que receba um inteiro positivo e retorne a soma do cubo de todos os inteiros positivos menores que o número especificado.
    \item Escreva uma função Python que recebe um inteiro positvo e retorna o menor digito deste número.
    \item Escreva uma função que calcule o fatorial de um número inteiro. A seguir compare a eficiência do seu código com as funções factorial disponíveis nos pacotes {\bf math} e {\bf numpy}. Use o {\tt \%timeit} para isso.
    \item Escreva uma função para calcular a função $\text{sinc}(x)$ que dada por
    \[ \text{sinc } x = \frac{\sin x}{x}.\]
    Garanta que a função calcule corretamente o caso $x=0$ (esse é um dos limites fundamentais que você aprendeu em Cálculo I).
    \item Crie uma lista $x=[1,2,\cdots,1000]$. Crie uma lista $y=[f(1), f(2), \cdots, f(1000)]$ onde 
    \[ f(n) = \left(1 + \frac{1}{n}\right)^n - e\]
    (tente utilizar o pacote numpy). Faça um plot do gráfico de $f(n)$. O que você conclui sobre
    \[ \lim_{n \rightarrow + \infty} \left(1 + \frac{1}{n}\right)^n = ? \]
    \item Um número $T$ é chamado triangular quando existe um inteiro $N$ tal que
    \[ T = 1+2+ \cdots+ N.\]
    Por exemplo, $3(=1+2)$, $6(=1+2+3)$, $10(=1+2+3+4)$ são números triangulares. Construa uma função que calcula o $n$-ésimo número triangular.
    \item Construa gráficos das funções abaixo em uma única figura
    \[(a) f(x)=x^4 e^{-x},\,\,\, (b) 2x^2e^{-x} \sin(x^2)\]
Sua figura deve ter legenda, título, nomes nos eixos e um grid.

    \item  Quando escrevemos um número $n$ na base decimal estamos implicitamente dizendo:
\[ n = d_N 10^N + d_{N-1} 10^{N-1} + \cdots + d_2 10^2 + d_1 10^1 + d_0 10^0 \]
onde $N+1$ é o número de dígitos de $n$ e $d_k = 0,\cdots,9$, $k=0,\cdots,N$ são os dígitos desse número ($d_N \neq 0)$. Da mesma forma $n$ pode ser escrito na base binária, onde os digitos dão $b_j = 0,1 $ fazendo
\[ n = b_m 2^m + b_{m-1} 2^{m-1}+ \cdots + b_2 2^2 + b_1 2^1 + b_0 2^0. \]
É claro que o maior número que pode ser escrito em base binária com $m$ dígitos é
\[ n_{max} = 2^m + 2^{m-1}+ \cdots + 2^2 + 2^1 +  2^0 = 2^{m+1}-1 \]
resultado que obtemos reconhecendo a série geométrica finita na expressão acima. Vamos escrever um código que converte um número da base decimal para a base binária.
    \item Um problema clássico em olimpíadas de matemática para o nível fundamental é o {\it Problema dos Armários}. O problema é o seguinte: Em uma escola existem 1000 armários numerados (de 1 a 1000) e 1000 alunos. No primeiro dia de aula, o Diretor reúne todos os 1000 alunos em fila. O Diretor então manda que o primeiro aluno da fila abra todos os armários. Após esse aluno terminar a tarefa, o diretor ordena que o próximo estudante (i.e. o segundo aluno da fila) feche todos os armários com número par. Quando ele conclui a tarefa o diretor, manda que o terceiro aluno da fila mude o estado de todos os armários com número divisível por 3. Mudar o estado significa se o armário estiver aberto, ele irá fecha-lo e se o armário estiver fechado, ele irá abri-lo. Ao quarto aluno, o diretor mandará que mude o estado de todos os armários divisíveis por 4, ao quinto aluno que mude o estado de todos os armários divisíveis por 5, e assim sucessivamente até que todos os 1000 alunos tenham participado.
    \begin{enumerate}
        \item Escreva um programa para simular o problema descrito. O programa deve ser capaz de determinar aos final do processo: quais armários estão abertos, quais estão fechados e o número total de armários abertos.
        \item Como disse na introdução este é um problema de matemática. A resolução esperada do {\it Problema dos Armários} não envolve computação, mas sim a compreensão de propriedades de divisores de números inteiros. Vamos tentar entender essa propriedade usando um programa de computador: Construa um programa que analisa os 10 mil primeiros números inteiros e separa em uma lista aqueles que tem um número ímpar de divisores. Verifique que todos estes números são quadrados perfeitos. Suponha que esta é uma propriedade geral, como ela pode ser usada para responder o {\it Problema dos Armários}.
        \item {\bf (Opcional)} Demonstre matematicamente a propriedade conjecturada no item anterior, i.e.  ``Um número inteiro positivo é um quadrado perfeito se e somente se ele possui um número ímpar de divisores''.
    \end{enumerate}
\end{enumerate}

